<html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>JSX | XML-like syntax extension to ECMAScript</title><meta name="viewport" content="width=device-width"><meta property="og:title" content="JSX | XML-like syntax extension to ECMAScript"><meta property="og:type" content="website"><meta property="og:url" content="http://facebook.github.io/jsx/index.html"><meta property="og:description" content="XML-like syntax extension to ECMAScript"><link rel="stylesheet" href="/jsx/css/jsx.css"><script type="text/javascript" src="//use.typekit.net/vqa1hcx.js"></script><script type="text/javascript">try{Typekit.load();}catch(e){}</script></head><body><div class="container"><div class="nav-main"><div class="wrap"><a class="nav-home" href="/jsx/">JSX</a><ul class="nav-site"><li><a href="http://github.com/facebook/jsx" class="">github</a></li></ul></div></div><div class="hero"><div class="wrap"><div class="text">Draft: <strong>JSX Specification</strong></div><div class="minitext">XML-like syntax extension to ECMAScript</div></div></div><section class="content wrap"><section class="home-section"><div><p>JSX is a XML-like syntax extension to ECMAScript without any defined semantics. It&#x27;s NOT intended to be implemented by engines or browsers. <strong>It&#x27;s NOT a proposal to incorporate JSX into the ECMAScript spec itself.</strong> It&#x27;s intended to be used by various preprocessors (transpilers) to transform these tokens into standard ECMAScript.</p><div class="prism language-javascript"><span class="token comment" spellcheck="true">// Using JSX to express UI components.
</span><span class="token keyword">var</span> dropdown <span class="token operator">=</span>
  &lt;Dropdown<span class="token operator">&gt;</span>
    A dropdown list
    &lt;Menu<span class="token operator">&gt;</span>
      &lt;MenuItem<span class="token operator">&gt;</span>Do Something&lt;<span class="token operator">/</span>MenuItem<span class="token operator">&gt;</span>
      &lt;MenuItem<span class="token operator">&gt;</span>Do Something Fun<span class="token operator">!</span>&lt;<span class="token operator">/</span>MenuItem<span class="token operator">&gt;</span>
      &lt;MenuItem<span class="token operator">&gt;</span>Do Something Else&lt;<span class="token operator">/</span>MenuItem<span class="token operator">&gt;</span>
    &lt;<span class="token operator">/</span>Menu<span class="token operator">&gt;</span>
  &lt;<span class="token operator">/</span>Dropdown<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token function">render<span class="token punctuation">(</span></span>dropdown<span class="token punctuation">)</span><span class="token punctuation">;</span></div><h2><a class="anchor" name="rationale"></a>Rationale <a class="hash-link" href="#rationale">#</a></h2><p>The purpose of this specification is to define a concise and familiar syntax for defining tree structures with attributes. A generic but well defined syntax enables a community of independent parsers and syntax highlighters to conform to a single specification.</p><p>Embedding a new syntax in an existing language is a risky venture. Other syntax implementors or the existing language may introduce another incompatible syntax extension.</p><p>Through a stand-alone specification, we make it easier for implementors of other syntax extensions to consider JSX when designing their own syntax. This will hopefully allow various new syntax extensions to co-exist.</p><p>It is our intention to claim minimal syntactic real estate while keeping the syntax concise and familiar. That way we leave the door open for other extensions.</p><p>This specification does not attempt to comply with any XML or HTML specification. JSX is designed as an ECMAScript feature and the similarity to XML is only for familiarity.</p><h2><a class="anchor" name="syntax"></a>Syntax <a class="hash-link" href="#syntax">#</a></h2><p><em>JSX extends the PrimaryExpression in the <a href="http://people.mozilla.org/~jorendorff/es6-draft.html" target="_blank">ECMAScript 6th Edition (ECMA-262)</a> grammar:</em></p><p>PrimaryExpression :</p><ul><li>JSXElement</li></ul><p><strong>Elements</strong></p><p>JSXElement :</p><ul><li><p>JSXSelfClosingElement</p></li><li><p>JSXOpeningElement JSXChildren<sub>opt</sub> JSXClosingElement&lt;br /&gt;
(names of JSXOpeningElement and JSXClosingElement should match)</p></li></ul><p>JSXSelfClosingElement :</p><ul><li><code>&lt;</code> JSXElementName JSXAttributes<sub>opt</sub> <code>/</code> <code>&gt;</code></li></ul><p>JSXOpeningElement :</p><ul><li><code>&lt;</code> JSXElementName JSXAttributes<sub>opt</sub> <code>&gt;</code></li></ul><p>JSXClosingElement :</p><ul><li><code>&lt;</code> <code>/</code> JSXElementName <code>&gt;</code></li></ul><p>JSXElementName :</p><ul><li>JSXIdentifier</li><li>JSXNamespacedName</li><li>JSXMemberExpression</li></ul><p>JSXIdentifier :</p><ul><li>IdentifierStart</li><li>JSXIdentifier IdentifierPart</li><li>JSXIdentifier <strong>NO WHITESPACE OR COMMENT</strong> <code>-</code></li></ul><p>JSXNamespacedName :</p><ul><li>JSXIdentifier <code>:</code> JSXIdentifier</li></ul><p>JSXMemberExpression :</p><ul><li>JSXIdentifier <code>.</code> JSXIdentifier</li><li>JSXMemberExpression <code>.</code> JSXIdentifier</li></ul><p><strong>Attributes</strong></p><p>JSXAttributes :</p><ul><li>JSXSpreadAttribute JSXAttributes<sub>opt</sub></li><li>JSXAttribute JSXAttributes<sub>opt</sub></li></ul><p>JSXSpreadAttribute :</p><ul><li><code>{</code> <code>...</code> AssignmentExpression <code>}</code></li></ul><p>JSXAttribute :</p><ul><li>JSXAttributeName <code>=</code> JSXAttributeValue</li></ul><p>JSXAttributeName :</p><ul><li>JSXIdentifier</li><li>JSXNamespacedName</li></ul><p>JSXAttributeValue :</p><ul><li><code>&quot;</code> JSXDoubleStringCharacters<sub>opt</sub> <code>&quot;</code></li><li><code>&#x27;</code> JSXSingleStringCharacters<sub>opt</sub> <code>&#x27;</code></li><li><code>{</code> AssignmentExpression <code>}</code></li><li>JSXElement</li></ul><p>JSXDoubleStringCharacters :</p><ul><li>JSXDoubleStringCharacter JSXDoubleStringCharacters<sub>opt</sub></li></ul><p>JSXDoubleStringCharacter :</p><ul><li>SourceCharacter <strong>but not <code>&quot;</code></strong></li></ul><p>JSXSingleStringCharacters :</p><ul><li>JSXSingleStringCharacter JSXSingleStringCharacters<sub>opt</sub></li></ul><p>JSXSingleStringCharacter :</p><ul><li>SourceCharacter <strong>but not <code>&#x27;</code></strong></li></ul><p><strong>Children</strong></p><p>JSXChildren :</p><ul><li>JSXChild JSXChildren<sub>opt</sub></li></ul><p>JSXChild :</p><ul><li>JSXText</li><li>JSXElement</li><li><code>{</code> AssignmentExpression<sub>opt</sub> <code>}</code></li></ul><p>JSXText :</p><ul><li>JSXTextCharacter JSXText<sub>opt</sub></li></ul><p>JSXTextCharacter :</p><ul><li>SourceCharacter <strong>but not one of <code>{</code>, <code>&lt;</code>, <code>&gt;</code> or <code>}</code></strong></li></ul><p><strong>Whitespace and Comments</strong></p><p><em>JSX uses the same punctuators and braces as ECMAScript. WhiteSpace, LineTerminators and Comments are generally allowed between any punctuators.</em></p><h2><a class="anchor" name="parser-implementations"></a>Parser Implementations <a class="hash-link" href="#parser-implementations">#</a></h2><ul><li><a href="https://github.com/RReverser/acorn-jsx" target="_blank">acorn-jsx</a>: A fork of acorn.</li><li><a href="https://github.com/facebook/esprima" target="_blank">esprima-fb</a>: A fork of esprima.</li><li><a href="https://github.com/jlongster/jsx-reader" target="_blank">jsx-reader</a>: A sweet.js macro.</li></ul><h2><a class="anchor" name="transpilers"></a>Transpilers <a class="hash-link" href="#transpilers">#</a></h2><p>These are a set of transpilers that all conform to the JSX syntax but use different semantics on the output:</p><ul><li><a href="https://github.com/vjeux/jsxdom" target="_blank">JSXDOM</a>: Create DOM elements using JSX.</li><li><a href="https://github.com/Raynos/mercury-jsx" target="_blank">Mercury JSX</a>: Create virtual-dom VNodes or VText using JSX.</li><li><a href="http://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank">React JSX</a>: Create ReactElements using JSX.</li></ul><p>NOTE: A conforming transpiler may choose to use a subset of the JSX syntax.</p><h2><a class="anchor" name="why-not-template-literals"></a>Why not Template Literals? <a class="hash-link" href="#why-not-template-literals">#</a></h2><p><a href="http://people.mozilla.org/~jorendorff/es6-draft.html" target="_blank">ECMAScript 6th Edition (ECMA-262)</a> introduces template literals which are intended to be used for embedding DSL in ECMAScript. Why not just use that instead of inventing a syntax that&#x27;s not part of ECMAScript?</p><p>Template literals work well for long embedded DSLs. Unfortunately the syntax noise is substantial when you exit in and out of embedded arbitrary ECMAScript expressions with identifiers in scope.</p><div class="prism language-javascript"><span class="token comment" spellcheck="true">// Template Literals
</span><span class="token keyword">var</span> box <span class="token operator">=</span> jsx`
  &lt;$<span class="token punctuation">{</span>Box<span class="token punctuation">}</span><span class="token operator">&gt;</span>
    $<span class="token punctuation">{</span>
      <span class="token function">shouldShowAnswer<span class="token punctuation">(</span></span>user<span class="token punctuation">)</span> <span class="token operator">?</span>
      jsx`&lt;$<span class="token punctuation">{</span>Answer<span class="token punctuation">}</span> value<span class="token operator">=</span>$<span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>no&lt;<span class="token operator">/</span>$<span class="token punctuation">{</span>Answer<span class="token punctuation">}</span><span class="token operator">&gt;</span>` <span class="token punctuation">:</span>
      jsx`
        &lt;$<span class="token punctuation">{</span>Box<span class="token punctuation">.</span>Comment<span class="token punctuation">}</span><span class="token operator">&gt;</span>
         Text Content
        &lt;<span class="token operator">/</span>$<span class="token punctuation">{</span>Box<span class="token punctuation">.</span>Comment<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      `
    <span class="token punctuation">}</span>
  &lt;<span class="token operator">/</span>$<span class="token punctuation">{</span>Box<span class="token punctuation">}</span><span class="token operator">&gt;</span>
`<span class="token punctuation">;</span></div><p>It would be possible to use template literals as a syntactic entry point and change the semantics inside the template literal to allow embedded scripts that can be evaluated in scope:</p><div class="prism language-javascript"><span class="token comment" spellcheck="true">// Template Literals with embedded JSX
</span><span class="token keyword">var</span> box <span class="token operator">=</span> jsx`
  &lt;Box<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span>
      <span class="token function">shouldShowAnswer<span class="token punctuation">(</span></span>user<span class="token punctuation">)</span> <span class="token operator">?</span>
      &lt;Answer value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>no&lt;<span class="token operator">/</span>Answer<span class="token operator">&gt;</span> <span class="token punctuation">:</span>
      &lt;Box<span class="token punctuation">.</span>Comment<span class="token operator">&gt;</span>
         Text Content
      &lt;<span class="token operator">/</span>Box<span class="token punctuation">.</span>Comment<span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
  &lt;<span class="token operator">/</span>Box<span class="token operator">&gt;</span>
`<span class="token punctuation">;</span></div><p>However, this would lead to further divergence. Tooling that is built around the assumptions imposed by template literals wouldn&#x27;t work. It would undermine the meaning of template literals. It would be necessary to define how JSX behaves within the rest of the ECMAScript grammar within the template literal anyway.</p><p>Therefore it&#x27;s better to introduce JSX as an entirely new type of PrimaryExpression:</p><div class="prism language-javascript"><span class="token comment" spellcheck="true">// JSX
</span><span class="token keyword">var</span> box <span class="token operator">=</span>
  &lt;Box<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span>
      <span class="token function">shouldShowAnswer<span class="token punctuation">(</span></span>user<span class="token punctuation">)</span> <span class="token operator">?</span>
      &lt;Answer value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>no&lt;<span class="token operator">/</span>Answer<span class="token operator">&gt;</span> <span class="token punctuation">:</span>
      &lt;Box<span class="token punctuation">.</span>Comment<span class="token operator">&gt;</span>
         Text Content
      &lt;<span class="token operator">/</span>Box<span class="token punctuation">.</span>Comment<span class="token operator">&gt;</span>
    <span class="token punctuation">}</span>
  &lt;<span class="token operator">/</span>Box<span class="token operator">&gt;</span><span class="token punctuation">;</span></div><h2><a class="anchor" name="why-not-jxon"></a>Why not JXON? <a class="hash-link" href="#why-not-jxon">#</a></h2><p>Another alternative would be to use object initializers (similar to <a href="https://developer.mozilla.org/en-US/docs/JXON" target="_blank">JXON</a>). Unfortunately, the balanced braces do not give great syntactic hints for where an element starts and ends in large trees. Balanced named tags is a critical syntactic feature of the XML-style notation.</p><h2><a class="anchor" name="prior-art"></a>Prior Art <a class="hash-link" href="#prior-art">#</a></h2><p>The JSX syntax is similar to the <a href="http://www.ecma-international.org/publications/standards/Ecma-357.htm" target="_blank">E4X Specification (ECMA-357)</a>. E4X is a deprecated specification with deep reaching semantic meaning. JSX partially overlaps with a tiny subset of the E4X syntax. However, JSX has no relation to the E4X specification.</p><h2><a class="anchor" name="license"></a>License <a class="hash-link" href="#license">#</a></h2><p>Copyright (c) 2014, Facebook, Inc.
All rights reserved.</p><p>This work is licensed under a <a href="http://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0
International License</a>.</p></div></section></section><footer class="wrap"><div class="right">© 2014 Facebook Inc.</div></footer></div><div id="fb-root"></div><script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
            ga('create', 'UA-387204-10', 'facebook.github.io');
            ga('send', 'pageview');

            !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)
            ){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";
            fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");
          </script></body></html>